\documentclass[english,nohyper,titlepage]{tufte-handout}
\usepackage{charter}
\usepackage{helvet}
\renewcommand{\familydefault}{\rmdefault}
\usepackage[latin9]{inputenc}
\usepackage{color}
\usepackage{natbib}
%\usepackage{cite}
\usepackage{babel}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage[unicode=true,pdfusetitle,bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
            breaklinks=false,pdfborder={0 0 0},backref=false,colorlinks=true] {hyperref}
\hypersetup{urlcolor= RedOrange, citecolor=RedOrange, linkcolor=RedOrange}
\fancyhf{}% clear previous contents of running heads/feet
\fancyhead[RE]{\footnotesize{Machine Learning\qquad{} \thepage}}
\fancyhead[LO]{\footnotesize{\thepage \qquad{}Applications in R}}
%\rhead{myrhead}
\makeatletter
\newcommand{\sgn}{\operatorname{sgn}} %define the sign operator


\title{\LARGE An Introduction to Machine Learning \\ 
\noindent \normalsize With Applications in R\normalsize}

\author{{\small Michael Clark\\
         \noindent Center for Social Research\\
         \noindent University of Notre Dame\\}}
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}


\AtBeginDocument{
\def\labelitemi{} %%%%\(\cdot\) remove bullet
}

\makeatother

\begin{document}
\bibliographystyle{apa}

\maketitle
\pagebreak{}
\tableofcontents{}
\pagebreak{}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Preface}

The purpose of this document is to provide a conceptual introduction to statistical or machine learning (ML) techniques for those that might not normally be exposed to such approaches during their required typical statistical training\sidenote{I generally have in mind social science researchers but hopefully keep present the material broadly enough for anyone that may be interested.}.  Machine learning\sidenote{Also referred to as applied statistical learning, statistical engineering, data science or data mining in other contexts.} can be described as a form of a statistics, often even utilizing well-known nad familiar techniques, that has bit of a different focus than traditional analytical practice in the social sciences and other disciplines.  The key notion is that flexible, automatic approaches are used to detect patterns within the data, with a primary focus on making predictions on future data.

If one surveys the number of techniques available in ML without context, it will surely be overwhelming in terms of the sheer number of those approaches and also the various tweaks and variations of them.  However, the specifics of the techniques are not as important as more general concepts that would be applicable in most every ML setting, and indeed, many traditional ones as well.  While there will be examples using the R statistical environment and descriptions of a few specific approaches, the focus here is more on ideas than application\sidenote{Indeed, there is evidence that with large enough samples many techniques converge to similar performance.} and kept at the conceptual level as much as possible.  However, some applied examples of more common techniques will be provided in detail.

As for prerequisite knowledge, I will assume a basic familiarity with regression analyses typically presented to those in applied disciplines, particularly those of the social sciences.  Regarding programming, one should be at least somewhat familiar with using R and Rstudio, and either of my introductions \href{http://www.nd.edu/~mclark19/learn/Introduction_to_R.pdf}{here} and \href{http://www.nd.edu/~mclark19/learn/Introduction_to_R_II.pdf}{here} will be plenty.  Note that I won't do as much explaining of the R code as in those introductions, and in some cases I will be more concerned with getting to a result than clearly detailing the path to it.  Armed with such introductory knowledge as can be found in those documents, if there are parts of R code that are unclear one would have the tools to investigate and discover for themselves the details, which results in more learning anyway.

\marginnote{The latest version of this document is dated \today{} (original March 2013).}
\pagebreak{}


% !Rnw root = ../mlcrash.Rnw




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Introduction: Explanation \& Prediction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newthought{For any particular analysis conducted}, emphasis can be placed on understanding the underlying mechanisms which have specific theoretical underpinnings, versus a focus that dwells more on performance and, more to the point, future performance.  These are not mutually exclusive goals in the least, and probably most studies contain a little of both in some form or fashion.  I will refer to the former emphasis as that of \emph{explanation}, and the latter that of \emph{prediction}.

In studies with a more explanatory focus, traditionally analysis concerns a single data set.  For example, one assumes a data generating distribution for the response, and one evaluates the overall fit of a single model to the data at hand, e.g. in terms of R-squared, and statistical significance for the various predictors in the model.  One assesses how well the model lines up with the theory that led to the analysis, and modifies it accordingly, if need be, for future studies to consider.  Some studies may look at  predictions for specific, possibly hypothetical values of the predictors, or examine the particular nature of individual predictors effects.  In many cases, only a single model is considered.  In general though, little attempt is made to explicitly understand how well the model will do with future data, but we hope to have gained greater insight as to the underlying mechanisms guiding the response of interest.  Following \citet{breiman_statistical_2001}, this would be more akin to the \emph{data modeling culture}.

For the other type of study focused on prediction, newer techniques are available that are far more focused on performance, not only for the current data under examination but for future data the selected model might be applied to.  While still possible, relative predictor importance is less of an issue, and oftentimes there may be no particular theory to drive the analysis.  There may be thousands of input variables, such that no simple summary would likely be possible anyway.  However, many of the techniques applied in such analyses are quite powerful, and steps are taken to ensure better results for new data.  Again referencing \citet*{breiman_statistical_2001}, this perspective is more of the \emph{algorithmic modeling culture}.

While the two approaches are not exclusive, I present two extreme views of the situation:

\begin{quote}
To paraphrase provocatively, 'machine learning is statistics minus any checking of models and assumptions'.
\textasciitilde Brian Ripley, 2004
\end{quote}
\begin{quote}
... the focus in the statistical community on data models has:\\
Led to irrelevant theory and questionable scientific conclusions.\\
Kept statisticians from using more suitable algorithmic models.\\
Prevented statisticians from working on exciting new problems.
\textasciitilde Leo Brieman, 2001
\end{quote}


Respective departments of computer science and statistics now overlap more than ever as more relaxed views seem to prevail today, but there are potential drawbacks to placing too much emphasis on either approach historically associated with them.  Models that 'just work' have the potential to be dangerous if they are little understood.  Situations for which much time is spent sorting out details for an ill-fitting model suffers the converse problem- some (though often perhaps very little actually) understanding with little pragmatism.  While this paper will focus on more algorithmic approaches, guidance will be provided with an eye toward their use in situations where the typical data modeling approach would be applied, thereby hopefully shedding some light on a path toward obtaining the best of both worlds.

\section{Some Terminology}
For those used to statistical concepts such as dependent variables, clustering, and predictors, etc. you will have to get used to some differences in terminology\sidenote{See  \href{www-stat.stanford.edu/~tibs/stat315a/glossary.pdf}{this} for a comparison} such as targets, unsupervised learning, and inputs etc.  This doesn't take too much, even if it is somewhat annoying when one is first starting out.  I won't be too beholden to either in this paper, and it should be clear from the context what's being referred to.  Initially I will start off mostly with non-ML terms and note in brackets it's ML version to help the orientation along.



% !Rnw root = ../mlcrash.Rnw




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Tools You Already Have}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newthought{One thing that is important to keep in mind as you begin} is that standard techniques are still available, although we might tweak them or do more with them.  So having a basic background in statistics is all that is required to get started with machine learning.  Again, the difference between ML and traditional statistical analysis is one more of focus than method.

%%%
\section{The Standard Linear Model}
All introductory statistics courses will cover linear regression in great detail, and it certainly can serve as a starting point here.  We can describe it as follows in matrix notation:

%% changed vspace to push to next page, change back if later edits spill over to that point anyway
\vspace{1cm}
\noindent$y = N(\mu,\sigma^{2})$\\
\noindent$\mu = X\beta$
\vspace{.25cm}

Where y is a normally distributed vector of responses [\emph{target}] with mean $\mu$ and constant variance $\sigma^{2}$.  X is a typical model matrix, i.e. a matrix of predictor variables and in which the first column is a vector of 1s for the intercept [\emph{bias}\sidenote{Yes, you will see 'bias' refer to an intercept, and also mean something entirely different in our discussion of bias vs. variance.}], and $\beta$ is the vector of coefficients [\emph{weights}] corresponding to the intercept and predictors in the model.

What might be given less focus in applied courses however is how often it won't be the best tool for the job or even applicable in the form it is presented.  Because of this many applied researchers are still hammering screws with it, even as the explosion of statistical techniques of the past quarter century has rendered obsolete many current introductory statistical texts that are written for disciplines.  Even so, the concepts one gains in learning the standard linear model are generalizable, and even a few modifications of it, while still maintaining the basic design, can render it still very effective in situations where it is appropriate.

Typically in fitting [\emph{learning}] a model we tend to talk about R-squared and statistical significance of the coefficients for a small number of predictors.  For our purposes, let the focus instead be on the residual sum of squares\sidenote{$\sum(y-f(x))^{2}$ where $f(x)$ is a function of the model predictors, and in this context a linear combination of them ($X\beta$).} with an eye towards its reduction and model comparison. We will not have a situation in which we are only considering one model fit, and so must find one that reduces the sum of the squared errors but without unnecessary complexity and overfitting, concepts we'll return to later.  Furthermore, we will be much more concerned with the model fit on new data [\emph{generalization}].

%%%
\section{Logistic Regression}
Logistic regression is often used where the response is categorical in nature, usually with binary outcome in which some event occurs or does not occur [\emph{label}].  One could still use the standard linear model here, but you could end up with nonsensical predictions that fall outside the 0-1 range regarding the probability of the event occurring, to go along with other shortcomings.  Furthermore, it is no more effort nor is any understanding lost in using a logistic regression over the linear probability model.  It is also good to keep logistic regression in mind as we discuss other classification approaches later on.

Logistic regression is also typically covered in an introduction to statistics for applied disciplines because of the pervasiveness of binary responses, or responses that have been made as such\sidenote{It is generally a bad idea to discretize continuous variables, especially the dependent variable. However contextual issues, e.g. disease diagnosis, might warrant it.}.  Like the standard linear model, just a few modifications can enable one to use it to provide better performance, particularly with new data.  The gist is, it is not the case that we have to abandon familiar tools in the move toward a machine learning perspective.


%%%
\section{Expansions of Those Tools}

%%%
\subsection{Generalized Linear Models}
To begin, logistic regression is a generalized linear model assuming a binomial distribution for the response and with a logit link function as follows:

\vspace{.25cm}
\noindent$y = Bin(\mu, size=1)$\\
\noindent$\eta = g(\mu)$\\
\noindent$\eta = X\beta$\\
\vspace{.25cm}

This is the same presentation format as seen with the standard linear model presented before, except now we have a link function $g(.)$ and so are dealing with a transformed response.  In the case of the standard linear model, the distribution assumed is the gaussian and the link function is the identity link, i.e. no transformation is made. The link function used will depend on the analysis performed, and while there is choice in the matter, the distributions used have a typical, or canonical link function\sidenote{As another example, for the Poisson distribution, the typical link function would be the $log(\mu)$}.

Generalized linear models expand the standard linear model, which is a special case of generalized linear model, beyond the gaussian distribution for the response, and allow for better fitting models of categorical, count, and skewed response variables.  We have also have a counterpart to the residual sum of squares, though we'll now refer to it as the \emph{deviance}.

%%%
\subsection{Generalized Additive Models}
Additive models extend the generalized linear model to incorporate nonlinear relationships of predictors to the response. We might note it as follows:

\vspace{.25cm}
\noindent$y = family(\mu, ...)$\\
\noindent$\eta = g(\mu)$\\
\noindent$\eta = X\beta + f(X)$\\
\vspace{.25cm}

So we have the generalized linear model but also smooth functions $f(X)$ of one or more predictors.  More detail can be found in \citet{wood_generalized_2006} and I provide an introduction \href{http://www.nd.edu/~mclark19/learn/GAMS.pdf}{here}.  

Things do start to get fuzzy with GAMs.  It becomes more difficult to obtain statistical inference for the smoothed terms in the model, and the nonlinearity does not always lend itself to easy interpretation.  However really this just means that we have a little more work to get the desired level of understanding.  GAMs can be seen as a segue toward more black box/algorithmic techniques.  Compared to some of those techniques in machine learning, GAMs are notably more interpretable, though perhaps less so than GLMs.  Also, part of the estimation process includes regularization and validation in determining the nature of the smooth function, topics of which we will return later.


%\SweaveInput{lossfunc/loss.Rnw}

% !Rnw root = ../mlcrash.Rnw






%%%%%%%%%%%%%%%%%%%%%%%%
\part{The Loss Function}
%%%%%%%%%%%%%%%%%%%%%%%%
\newthought{Given a set of predictor variables} $X$ and some response $y$, we look for some function $f(X)$ to make predictions of y from those input variables.  We also need a function to penalize errors in prediction- a \emph{loss function}, $L(Y, f(X))$.  With chosen loss function, we then find the model which will minimize loss, generally speaking.  We will start with the familiar and note a couple others that might be used.

\section{Continuous Outcomes}
\subsection{Squared Error}
The classic loss function for linear models with continuous response is the squared error loss function, or the residual sum of squares.

\vspace{.25cm}
\noindent$L(Y, f(X)) = \sum(y-f(X))^2$
\vspace{.25cm}

\subsection{Absolute Error}
For an approach more robust to extreme observations, we might choose absolute rather than squared error as follows.  In this case, predictions are a conditional median rather than a conditional mean.

\vspace{.25cm}
\noindent$L(Y, f(X)) = \sum|(y-f(X))|$
\vspace{.25cm}

\subsection{Negative Log-likelihood}
We can also think of our usual likelihood methods learned in a standard applied statistics course as incorporating a loss function that is the negative log-likelihood pertaining to the model of interest.  If we assume a normal distribution for the response we can note the loss function as:

\vspace{.25cm}
\noindent$L(Y, f(X)) = n\ln{\sigma} + \sum \frac{1}{2\sigma^2}(y-f(X))^2$
\vspace{.25cm}

In this case it would converge to the same answer as the squared error/least squares solution.


\subsection{R Example}
The following provides code that one could use with the \textcolor{red}{optim} function in R to find estimates of regression coefficients (beta) that minimize the squared error.  X is a design matrix of our predictor variables with the first column a vector of 1s in order to estimate the intercept.  y is the continuous variable to be modeled\sidenote{Type ?optim at the console for more detail.}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
sqerrloss = \hlkwd{function}(beta, X, y) \{
    mu = X %*% beta
    \hlkwd{sum}((y - mu)^2)
\}

\hlkwd{set.seed}(123)
X = \hlkwd{cbind}(1, \hlkwd{rnorm}(100), \hlkwd{rnorm}(100))
y = \hlkwd{rowSums}(X[, -1] + \hlkwd{rnorm}(100))
out1 = \hlkwd{optim}(par = \hlkwd{c}(0, 0, 0), fn = sqerrloss, X = X, y = y)
out2 = \hlkwd{lm}(y ~ X[, 2] + X[, 3])  \hlcom{# check with lm }
\hlkwd{rbind}(\hlkwd{c}(out1$par, out1$value), \hlkwd{c}(\hlkwd{coef}(out2), \hlkwd{sum}(\hlkwd{resid}(out2)^2)))
\end{alltt}
\begin{verbatim}
##      (Intercept) X[, 2] X[, 3]      
## [1,]      0.2702 0.7336  1.048 351.1
## [2,]      0.2701 0.7337  1.048 351.1
\end{verbatim}
\end{kframe}
\end{knitrout}


\section{Categorical Outcomes}
Here we'll also look at some loss functions useful in classification problems. Note that there is not necessary exclusion in loss functions for continuous vs. categorical outcomes\sidenote{For example, we could use minimize squared errors in the case of classification also.}.

\subsection{Misclassification}
Probably the most straightforward is misclassification, or 0-1 loss.  If we note $f$ as the prediction, and for convenience we assume a [-1,1] response instead of a [0,1] response:

\vspace{.25cm}
\noindent$L(Y, f(X)) = \sum I(y\neq sign(f))$
\vspace{.25cm}

In the above, \emph{I} is the indicator function and so we are summing misclassifications.


\subsection{Binomial log-likelihood}

\vspace{.25cm}
\noindent$L(Y, f(X)) = \sum log(1 + e^{-2yf})$
\vspace{.25cm}

The above is in deviance form, but is equivalent to binomial log likelihood if $y$ is on the 0-1 scale.

\subsection{Exponential}
Exponential loss is yet another loss function at our disposal.

\vspace{.25cm}
\noindent$L(Y, f(X)) = \sum e^{-yf}$
\vspace{.25cm}

\subsection{Hinge Loss}
A final loss function to consider, typically used with support vector machines, is the hinge loss function.

\vspace{.25cm}
\noindent$L(Y, f(X)) = \max(1-yf, 0)$
\vspace{.25cm}

Here negative values of $yf$ are misclassifications, and so correct classifications do not contribute to the loss.  We could also note it as $\sum (1-yf)_+$ , i.e. summing only those positive values of $1-yf$.

\vspace{.25cm}
\marginnote{\includegraphics[scale=.5]{images/lossfuncs}}
Which of these might work best may be specific to the situation, but the gist is that they penalize negative values (misclassifications) more heavily and increasingly so the worse the misclassification (except for misclassification error, which penalizes all misclassifications equally), with their primary difference in how heavy that penalty is.  At right is a depiction of the loss as a functions above, taken from \citet{hastie_elements_2009}.






% !Rnw root = ../mlcrash.Rnw





%%%%%%%%%%%%%%%%%%%%%
\part{Regularization}
%%%%%%%%%%%%%%%%%%%%%
\newthought{It is important to note} that a model fit to a single data set might do very well with the data at hand, but then suffer when predicting independent data \sidenote{In terminology we will discuss further later, such models might have low bias but notable variance.}.  Also, oftentimes we are interested in a 'best' subset of predictors among a great many, and in this scenario the estimated coefficients are overly optimistic.  This general issue can be improved by shrinking estimates toward zero, such that some of the performance in the initial fit is sacrificed for improvement with regard to prediction.

Penalized estimation will provide estimates with some shrinkage, and we can use it with little additional effort with our common procedures.  Concretely, let's apply this to the standard linear model, where we are finding estimates of $\beta$ that minimize the squared error loss.

\vspace{.25cm}
$\hat\beta = \underset{\beta}{\mathrm{arg\, min}} \sum{(y-X\beta)^2}$ 
\vspace{.25cm}

In words, we're finding the coefficients that minimize the sum of the squared residuals.  With the approach to regression here we just add a penalty component to the procedure as follows.

\vspace{.25cm}
$\hat\beta = \underset{\beta}{\mathrm{arg\, min}} \sum{(y-X\beta)^2} + \lambda\overset{p}{\underset{j=1}{\sum}}{\left|\beta_j\right|}$ 
\vspace{.25cm}

%
In the above equation, $\lambda$ is our penalty term\sidenote{This can be set explicitly or also estimated via a validation approach.  As we do not know it beforehand, we can estimate it on a validation data set (not the test set) and then use the estimated value when estimating coefficients via cross-validation with the test set.  We will talk more about validation later.} for which larger values will result in more shrinkage.  It's applied to the $L_1$ or Manhattan norm of the coefficients, $\beta_1,\beta_2...\beta_p$, i.e. \emph{not including the intercept} $\beta_0$, and is the sum of their absolute values (commonly referred to as the \emph{lasso}\sidenote{See Tibshirani (1996) Regression shrinkage and selection via the lasso.}). For generalized linear and additive models, we can conceptually express a penalized likelihood as follows:

\vspace{.25cm}
$l_p(\beta) = l(\beta) - \lambda\overset{p}{\underset{j=1}{\sum}}{\left|\beta_j\right|}$ 
\vspace{.25cm}

As we are maximizing the likelihood the penalty is a subtraction, but nothing inherently different is shown.  This basic idea of adding a penalty term will be applied to all machine learning approaches, but as shown, we can apply such a tool to classical methods to boost prediction performance.

It should be noted that we can go about the regularization in different ways.  For example, using the squared $L_2$ norm results in what is called \emph{ridge} regression (a.k.a. Tikhonov regularization)\sidenote{Interestingly, the lasso and ridge regression results can be seen as a Bayesian approach using a zero mean Laplace and Normal prior distribution respectively for the $\beta_j$.}, and using a weighted combination of the lasso and ridge penalties gives us \emph{elastic net} regularization. 

%%%
\section{R Example}
In the following example, we take a look at the lasso approach for a standard linear model.  We add the regularization component, with a fixed penalty $\lambda$ for demonstration purposes\sidenote{As noted previously, in practice $\lambda$ would be estimated via some validation procedure.}.  However you should insert your own values for $\lambda$ in the \texttt{\textcolor{red}{optim}} line to see how the results are affected. 

\vspace{.25cm}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
sqerrloss_reg = \hlkwd{function}(beta, X, y, lambda=.1)\{
  mu = X%*%beta
  \hlkwd{sum}((y-mu)^2) + lambda*\hlkwd{sum}(\hlkwd{abs}(beta[-1]))
\}

out3 = \hlkwd{optim}(par=\hlkwd{c}(0,0,0), fn=sqerrloss_reg, X=X, y=y)
\hlkwd{rbind}(\hlkwd{c}(out1$par, out1$value), 
      \hlkwd{c}(\hlkwd{coef}(out2),\hlkwd{sum}(\hlkwd{resid}(out2)^2)), 
      \hlkwd{c}(out3$par, out3$value) )
\end{alltt}
\begin{verbatim}
##      (Intercept) X[, 2] X[, 3]      
## [1,]      0.2702 0.7336  1.048 351.1
## [2,]      0.2701 0.7337  1.048 351.1
## [3,]      0.2704 0.7328  1.047 351.3
\end{verbatim}
\end{kframe}
\end{knitrout}


From the above, we can see in this case that the predictor coefficients have indeed shrunk toward zero slightly while the residual sum of squares has increased just a tad.

In general, we can add the same sort of penalty to any number of models, such as logistic regression, neural net models, recommender systems etc.  The primary goal again is to hopefully increase our ability to generalize the selected model to new data.  Note that the estimates produced are in fact biased, but we have decreased the variance with new predictions as a counterbalance, and this brings us to the topic of the next section.



% !Rnw root = ../mlcrash.Rnw




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Bias-Variance Tradeoff}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newthought{In most of science} we are concerned with reducing uncertainty in our knowledge of some phenomenon.  The more we know about the factors involved or related to some outcome of interest, the better we can predict that outcome upon the influx of new information.  The initial step is to take the data at hand, and determine how well a model or set of models fit the data in various fashions.  In many applications however, this part is also more or less the end of the game as well\sidenote{I should note that I do not make any particular claim about the quality of such analysis.  In many situations the cost of data collection is very high, and for all the current enamorment with 'big' data, a lot of folks will never have access to big data for their situation (e.g. certain clinical populations).  In these situations getting new data for which one might make predictions is extremely difficult.}.

Unfortunately, such an approach in which we only fit models to one data set does not give a very good sense of \emph{generalization} performance, i.e. the performance we would see with new data.  While typically not reported, most researchers, if they are spending appropriate time with the data, are actually testing a great many models, for which the 'best' is then provided in detail in the end report.  Without some generalization performance check however, such performance is overstated when it comes to new data.

In the following consider a standard linear model scenario, e.g. with squared-error loss function and perhaps some regularization, and a data set in which we split the data in some random fashion into a \emph{training} set, for initial model fit, and a \emph{test} set, which is a separate and independent data set, to measure generalization performance\sidenote{In typical situations there are parameters specific to some analytical technique for which one would have no knowledge and which must be estimated along with the usual parameters of the standard models. The $\lambda$ penalty parameter in regularized regression is one example of such a \emph{tuning}parameter. In the best case scenario, we would also have a \emph{validation} set, where we could determine appropriate values for such parameters based on performance with the validation data set, and then assess generalization performance on the test set when the final model has been chosen.  However, methods are available to us in which we can approximate the validation step in other ways.}.  We note \emph{training error} as the (average) loss over the training set, and \emph{test error} as the (average) prediction error obtained when a model resulting from the training data is fit to the test data.  So in addition to the previously noted goal of finding the 'best' model (\emph{model selection}), we are interested further in estimating the prediction error with new data (\emph{model performance}).

%%%
\section{Bias \& Variance}
Conceptually\sidenote{Much of the following is essentially a paraphrase of parts of \citet[Chap. 2 \& 7]{hastie_elements_2009}.}, with the standard model $Y = f(X) + \epsilon$ with we can think of the expected prediction error at a specific input $X = x_0$ as: \\

\vspace{.25cm}
\noindent $\text{Error}_{x_0} = \text{Irreducible Error} + \text{Bias}^2 + \text{Variance}$
\vspace{.25cm}

In other words, we have three components to our general notion of prediction error: \\

\begin{description}
  \item[$\sigma^2_\epsilon$] An initial variance of the target around the true mean $f(x_0)$ (unavoidable).
  \item[$Bias^2$] the amount the \emph{average} of our estimate varies from the true mean.
  \item[Variance] the variance of the target value about its mean.
\end{description}

Slightly more formally, we can present this as follows, with $h_0$ our estimated (hypothesized) value:

\vspace{.25cm}
\noindent $\text{Error}_{x_0} = Var(\epsilon) + (\text{E}[h_0] - f(x_0))^2 + Var(h_0) $
\vspace{.25cm}


%%%
\section{The Tradeoff}
Outlining a general procedure, we start by noting the prediction error on a training data set with multiple models of varying complexity (e.g. increasing the number of predictor variables), and then assess the performance of the chosen models in terms of prediction error on the test set.  We then perform the same activity for a total of 100 simulated data sets, for each level of complexity.

\marginnote{\includegraphics[scale=.5]{images/biasvar2}}The results from this process might look like the image to the right taken from \citet{hastie_elements_2009}.  With regard to the training data, we have $error_{train}$ for one hundred training sets for each level of model complexity.  The bold blue line notes this average error over the 100 sets by model complexity.  The bold red line the average test error ($error_{test}$) across the 100 test data sets.

Ideally we'd like to see low bias and variance, but things are not so easy. One thing we can see clearly is that $error_{train}$ is not a good estimate of $error_{test}$, which is now our focus in terms of performance. If we think of the training error as what we would see in typical research where one does everything with a single data set, we are using the same data set to fit the model and assess error.  As the model is adapted to that data set specifically, it will be overly optimistic in the estimate of the error, that optimism being the difference between the error rate we see based on the training data versus the average of what we would get with many test data sets.  We can think of this as a problem of overfitting to the training data.  Models that do not incorporate any regularization or validation process of any kind are likely overfit to the data presented.

Generally speaking, the more complex the model, the lower the bias, but the higher the variance, as depicted in the graphic.  Specifically however, the situation is more nuanced, where type of problem (classification with 0-1 loss vs. continuous response with squared error loss\sidenote{See Friedman (1996) \emph{On Bias, Variance, 0/1 Loss and the Curse of Dimensionality} for the unusal situations that can arise in dealing with classification error with regard to bias and variance.}) and technique (a standard linear model vs. regularized fit) will exhibit different bias-variance relationships.

%%%
\section{Diagnosing Bias-Variance Issues \& Possible Solutions}
Let's assume a regularized linear model with a standard data split into training and test sets.  We will describe different scenarios with possible solutions.

\marginnote{\includegraphics[scale=.35]{images/biasvartarget} \footnotesize{Figure adapted from \citet{domingos_few_2012}.}}
\subsection{Worst Case Scenario}
Starting with the worst case scenario, poor models may exhibit high bias and high variance.  One thing that will not help this situation (perhaps contrary to intuition) is adding more data, i.e. increasing N.  You can't make a silk purse out of a sow's ear (\emph{usually}\sidenote{\url{https://libraries.mit.edu/archives/exhibits/purse/}}), and adding more data just gives you a more accurate picture of how awful your model is. One might need to rework the model, e.g. adding new predictors or creating them via interaction terms, polynomials, or other smooth functions as in additive models, or simply collecting better and/or more relevant data.\marginnote{\includegraphics[scale=.35]{images/graph64} \footnotesize{Figure inspired by \citet[figure 6.5]{murphy_machine_2012} showing the bias-variance tradeoff.  Sample (left) and average (right) fits of linear regression using a gaussian radial basis function expansion. The green line represents the true relationship. The top row shows low variance between one fit and the next (left) but notable bias (right) in that the average fit is off.  Compare to the less regularized (high variance, low bias) situation of the bottom row.  See the \emph{\textcolor{blue}{kernlab}} package for the fitting function used.}}


\subsection{High Variance}
When variance is a problem, our training error is low while test error is relatively high (overfitting problem). Implementing more shrinkage or other penalization to model complexity may help with the issue.  In this case more data may help as well.

\subsection{High Bias}
With bias issues our training error is high and test error is not too different from training error (underfitting problem).  Adding new predictors/features, interaction terms, polynomials etc. can help here.  Additionally reducing $\lambda$ would also work with even less effort.



% !Rnw root = ../mlcrash.Rnw




%%%%%%%%%%%%%%%%%%%%%%%
\part{Cross-Validation}
%%%%%%%%%%%%%%%%%%%%%%%
As noted in the previous section, in machine learning approaches we are particularly concerned with prediction error on new data.  The simplest validation approach would be to split the data available into a training and test set as discussed previously.  We estimate the model on the training data, and apply the model to the test data, get the predictions and measure our test error, selecting whichever model results in the least test error.  \marginnote{\center\includegraphics[scale=.2]{images/learningcurve.pdf}}A hypothetical learning curve display the results of such a process is shown to the right. While fairly simple, other approaches are more commonly used and result in better estimates of performance\sidenote{Along with some of the other works cited, see \citet{harrell_regression_2001} for a good discussion of model validation.}.

\section{Adding Another Validation Set}
One technique that might be utilized for larger data sets, is to split the data into training, validation and final test sets.  For example, one might take the original data and create something like a 60-20-20\% split to create the needed data sets.  The purpose of the initial validation set is to select the optimal model and determine the values of tuning parameters.  These are parameters which generally deal with how complex a model one will allow, but for which one would have little inkling as to what they should be set at before hand (e.g. our $\lambda$ shrinkage parameter).  We select models/tuning parameters that minimize the validation set error, and once the model is chosen examine test set error performance.  In this way performance assessment is still independent of the model development process.

\section{K-fold Cross-Validation}
\marginnote{\includegraphics[scale=1]{images/kfold.pdf} \vspace{.5cm} \\ An illustration of 3-fold classification.}In many cases we don't have enough data for such a split, and the split percentages are arbitrary anyway and results would be specific to the specific split chosen.  Instead we can take a typical data set and randomly split it into $\kappa=10$ equal-sized (or close to it) parts.  Take the first nine partitions and use them as the training set.  With chosen model, make predictions on the test set.  Now do the same but this time use the 9th partition as the holdout set. Repeat the process until each of the initial 10 partitions of data have been used as the test set.  Average the error across all procedures for our estimate of prediction error.  With enough data, this (and the following methods) could be used as the validation procedure before eventual performance assessment on an independent test set with the final chosen model.

\subsection{Leave-one-out Cross-Validation}
Leave-one-out (LOO) cross-validation is pretty much the same thing but where $\kappa=N$.  In other words, we train a model for all observations except the $\kappa^{th}$ one, assessing fit on the observation that was left out. We then cycle through until all observations have been left out once to obtain an average accuracy.  

Of the two, K-fold may have relatively higher bias but less variance, while LOO would have the converse problem, as well as possible computational issues\sidenote{For squared-error loss situations, there is a Generalized cross-validation (GCV) that can be estimated more directly without actually going to the entire LOO procedure, and functions similarly to AIC.}.  K-fold's additional bias would be diminished would with increasing sample sizes, and generally 5 or 10-fold cross-validation is recommended.

\section{Bootstrap}
With a bootstrap approach, we draw $B$ random samples with replacement from our original data set, creating $B$ bootstrapped data sets of the same size as the original data.  We use the $B$ data sets as training sets and, using the original data as the test set, average the prediction error across the models.

\section{Other Stuff}
Along with the above there are variations such as repeated cross validation, the '.632' bootstrap and so forth.  One would want to do a bit of investigating, but $\kappa$-fold and bootstrap approaches generally perform well.  If variable selection is part of the goal, one should be selecting subsets of predictors as part of the cross-validation process, not at some initial data step.




% !Rnw root = ../mlcrash.Rnw




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Model Assessment \& Selection}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newthought{In typical model comparison} within the standard linear model framework, there are a number of ways in which we might assess performance across competing models.  For standard OLS regression we might examine adjusted-$R^2$, or with the generalized linear models we might pick a model with the lowest AIC\sidenote{In situations where it is appropriate to calculate in the first place, AIC can often compare to the bootstrap and k-fold cross-validation approaches.}.  As we have already discussed, in the machine learning context we are interested in models that reduce e.g. squared error loss (regression) or misclassification error (classification).  However in dealing with many models some differences in performance may be arbitrary.

%%%
\subsection{Beyond Classification Accuracy: Other Measures of Performance}
In typical classification situations we are interested in overall accuracy.  However there are situations, not uncommon, in which simple accuracy isn't a good measure of performance.  As an example, consider the prediction of the occurrence of a rare disease. Guessing a non-event every time might result in 99.9\% accuracy, but that isn't how we would prefer to go about assessing some classifier's performance.
To demonstrate other sources of classification information, we will use the following 2x2 table that shows values of some binary outcome (0 = non-event, 1 = event occurs) to the predictions made by some model for that response (arbitrary model).  Both a table of actual values, often called a \emph{confusion matrix}\sidenote{This term has always struck me as highly sub-optimal.}, and an abstract version are provided.


\begin{table}[ht]
\begin{minipage}[b]{0.45\linewidth}
    \begin{tabular}{llrr}
     & & & Actual \\
     \hline
     & & 1 & 0\\ 
     \hline
     Predicted & 1 &  41 &  21 \\ 
     & 0 &  16 &  13\\ 
     \hline
    \end{tabular}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.45\linewidth}
    \begin{tabular}{lrrr}
     & & & Actual \\
     \hline
     & & 1 & 0\\ 
     \hline
     Predicted & 1 &  A &  B \\ 
     & 0 &  C &  D\\ 
     \hline
    \end{tabular}
\end{minipage}
\end{table}

\small
\begin{description}
  \item[True Positive, False Positive, True Negative, False Negative] Above, these are A, B, D, and C respectively.
  \item[Accuracy] Number of correct classifications out of all predictions ((A+D)/Total). In the above example this would be (41+13)/91, about 59\%.
  \item[Error Rate] 1 - Accuracy.
  \item[Sensitivity] is the proportion of correctly predicted positives to all true positive events: A/(A+C).  In the above example this would be 41/57, about 72\%. High sensitivity would suggest a low type II error rate (see below), or high statistical \emph{power}. Also known as true positive rate.
  \item[Specificity] is the proportion of correctly predicted negatives to all true negative events: D/(B+D).  In the above example this would be 13/34, about 38\%. High specificity would suggest a low type I error rate (see below). Also known as true negative rate.
  \item[Postive Predictive Value (PPV)] proportion of true positives of those that are predicted positives: A/A+B. In the above example this would be 41/62, about 66\%.
  \item[Negative Predictive Value (NPV)] proportion of true negatives of those that are predicted negative: D/C+D. In the above example this would be 13/29, about 45\%.
  \item[Precision]  See PPV.
  \item[Recall] See sensitivity. 
  \item[Lift] Ratio of positive predictions given actual positives to the proportion of positive predictions out of the total: (A/(A+C))/((A+B)/Total). In the above example this would be (41/(41+16))/((41+21)/(91)), or 1.05.
  \item[F Score (F1 score)] Harmonic mean of precision and recall: 2*(Precision*Recall)/(Precision+Recall). In the above example this would be 2*(.66*.72)/(.66+.72), about .69.  Also known as F1 score.
  \item[Type I Error Rate (false positive rate)] proportion of true negatives that are incorrectly predicted positive: B/B+D. In the above example this would be 21/34, about 62\%.  Also known as alpha.
  \item[Type II Error Rate (false negative rate)] proportion of true positives that are incorrectly predicted negative: C/C+A. In the above example this would be 16/57, about 28\%. Also known as beta.
  \item[False Discovery Rate] proportion of false positives among all positive predictions: B/A+B. In the above example this would be 21/62, about 34\%.  Often used in multiple comparison testing in the context of ANOVA.
  \item[Phi coefficient] A measure of association: (A*D - B*C)/(sqrt((A+C)*(D+B)*(A+B)*(D+C))).  In the above example this would be .11.
\end{description}
\normalsize

Note the following summary of several measures where $N_+$ and $N_-$ are the total true positive values and total true negative values respectively, and $T_+$, $F_+$, $T_-$ and $F_-$ are true positive, false positive, etc.\sidenote{Table based on table 5.3 in \citet{murphy_machine_2012}}:
\vspace{.25cm}

{\footnotesize
\noindent\begin{tabular}{llll}
&  & Actual  & \\
& & 1 & 0 \\
\hline
Predicted & 1 & $T_+/N_+$ = TPR = sensitivity = recall & $F_+/N_-$ = FPR = Type I \\
& 0 & $F_-/N_+$ = FNR = Type II & $T_-/N_-$ = TNR = specificity \\
\hline
\end{tabular} 
}


\vspace{.25cm}
There are many other measures such as area under a ROC curve, odds ratio, and even more names for some of the above.  The gist is that given any particular situation you might be interested in one or several of them, and it would generally be a good idea to look at a few.



% !Rnw root = ../mlcrash.Rnw




%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Process Overview}
%%%%%%%%%%%%%%%%%%%%%%%%%%
\newthought{Despite the facade of a polished product} one finds in published research, most of the approach with the statistical analysis of data is full of data preparation, starts and stops, debugging, re-analysis, tweaking and fine-tuning etc. Statistical learning is no different in this sense.  Before we begin with explicit examples, it might be best to give a general overview of the path we'll take.

\section{Data Preparation}
As with any typical statistical project, probably most of the time will be spent preparing the data for analysis.  Data is never ready to analyze right away, and careful checks must be made in order to ensure the integrity of the information.  This would include correcting errors of entry, noting extreme values, possibly imputing missing data and so forth.  In addition to these typical activities, we will discuss a couple more things to think about during this initial data examination when engaged in machine learning.

\subsection{Define Data and Data Partitions}
As we have noted previously, ideally we will have enough data to create a \emph{hold-out}, \emph{test}, or \emph{validation} data set. This would be some random partition of the data such that we could safely conclude that the data in the test set comes from the same population as the training set. The training set is used to fit the initial models at various tuning parameter settings, with a 'best' model being that which satisfies some criterion on the validation set (or via a general validation process).  With final model and parameters chosen, generalization error will be assessed with the the performance of the final model on the test data.

\subsection{Feature Scaling}
Even with standard regression modeling, centering continuous variables (subtracting the mean) is a good idea so that intercepts and zero points in general are meaningful. Standardizing variables so that they have similar variances or ranges will help some procedures find their minimums faster.  Another common transformation is \emph{min-max} normalization\sidenote{\footnotesize{$score_{new} = \frac{score_{old}-min_{old}} {max_{old}-min_{old}} (max_{new}-min_{new})+min_{new}$ }}, which will transfer a scale to a new one of some chosen minimum and maximum.  Note that whatever approach is done, it must be done \emph{after} any explicit separation of data.  So if you have separate training and test sets, they should be scaled separately.

\subsection{Feature Engineering}
If we're lucky we'll have ideas on potential combinations or other transformations of the predictors we have available.  For example, in typical social science research there two-way interactions one is often predisposed to try, or perhaps one can sum multiple items to a single scale score that may be more relevant.  Another common technique is to use a dimension reduction scheme such as principal components, but this can (and probably should) actually be an implemented algorithm in the ML process\sidenote{For example, via principal components and partial least squares regression.}.

One can implement a variety of such approaches in ML as well to create additional potentially relevant features, even automatically, but as a reminder, a key concern is overfitting, and doing broad construction of this sort with no contextual guidance would potentially be prone to such a pitfall.  In other cases it may simply be not worth the time expense.

\subsection{Discretization}
While there may be some contextual exceptions to the rule, it is generally a pretty bad idea in standard statistical modeling to discretize/categorize continuous variables\sidenote{See \citet{harrell_regression_2001} for a good summary of reasons why not to.}.  However some ML procedures will work better (or just faster) if dealing with discrete valued predictors rather than continuous. Others even require them; for example, logic regression needs binary input.  While one could pick arbitrary intervals and cutpoints in an unsupervised fashion such as picking equal range bins or equal frequency bins, there are supervised algorithmic approaches that will use the information in the data to produce some 'optimal' discretization.

It's generally not a good idea to force things in data analysis, and given that a lot of data situations will be highly mixed, it seems easier to simply apply some scaling to preserve the inherent relationships in the data.  Again though, if one has only a relative few continuous variables or a context in which it makes sense to, it's probably better to leave continuous variables as such.

\section{Model Selection}
With data prepared and ready to analyze, one can use a validation process to come up with a viable model.  Use an optimization procedure or a simple grid search over a set of specific values to examine models at different tuning parameters. Perhaps make a finer search once an initial range of good performing values is found, though one should not split hairs over arbitrarily close performance.  Select a 'best' model given some criterion such as overall accuracy, or if concerned about over fitting, select the simplest model within one standard error of the accuracy of the best, or perhaps the simplest within X\% of the best model.  For highly skewed classes, one might need to use a different measure of performance besides accuracy.  If one has a great many predictor variables, one may use the model selection process to select features that are 'most important'.

\section{Model Assessment}
With tuning parameters/features chosen, we then examine performance on the independent test set (or via some validation procedure). For classification problems, consider other statistics besides accuracy as measures of performance, especially if classes are unbalanced. Consider other analytical techniques that are applicable and compare performance among the different approaches.  One can even combine disparate models' predictions to possibly create an even better classifier.










